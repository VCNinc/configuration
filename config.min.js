var{ModularTrustRoot:e}=require("@modular/smcc-core");class r{static new(o){const t=new r;if(1!==arguments.length)throw new RangeError("ModularConfiguration.new expects exactly one argument");if("object"!=typeof o||null===o)throw new TypeError("Options must be an object");if(!Number.isInteger(o.requestTimeout))throw new TypeError("Request timeout must be an integer");if(o.requestTimeout<=0)throw new RangeError("Request timeout must be positive");if(t.requestTimeout=o.requestTimeout,!Number.isInteger(o.maxPostLength))throw new TypeError("Max post length must be an integer");if(o.maxPostLength<=0)throw new RangeError("Max post length must be positive");if(t.maxPostLength=o.maxPostLength,!Number.isInteger(o.maxProfileLength))throw new TypeError("Max profile length must be an integer");if(o.maxProfileLength<=0)throw new RangeError("Max profile length must be positive");if(t.maxProfileLength=o.maxProfileLength,!Number.isInteger(o.maxPostCount))throw new TypeError("Max post count must be an integer");if(o.maxPostCount<=0)throw new RangeError("Max post count must be positive");if(t.maxPostCount=o.maxPostCount,!Number.isInteger(o.maxFollowCount))throw new TypeError("Max follow count must be an integer");if(o.maxFollowCount<=0)throw new RangeError("Max follow count must be positive");if(t.maxFollowCount=o.maxFollowCount,!Number.isInteger(o.recoveryDelay))throw new TypeError("Recovery delay must be an integer");if(o.recoveryDelay<0)throw new RangeError("Recovery delay cannot be negative");if(t.recoveryDelay=o.recoveryDelay,!Number.isInteger(o.maxConcurrentRequests))throw new TypeError("Max concurrent requests must be an integer");if(o.maxConcurrentRequests<=0)throw new RangeError("Max concurrent requests must be positive");if(t.maxConcurrentRequests=o.maxConcurrentRequests,!Number.isInteger(o.defaultNodePriority))throw new TypeError("Default node priority must be an integer");if(t.defaultNodePriority=o.defaultNodePriority,!Number.isInteger(o.pingPriorityThreshold))throw new TypeError("Ping priority threshold must be an integer");if(t.pingPriorityThreshold=o.pingPriorityThreshold,!Number.isInteger(o.defaultRequestPriority))throw new TypeError("Default request priority must be an integer");if(t.defaultRequestPriority=o.defaultRequestPriority,!Number.isInteger(o.discoveryRequestPriority))throw new TypeError("Discovery request priority must be an integer");if(t.discoveryRequestPriority=o.discoveryRequestPriority,!Number.isInteger(o.bootstrapRequestPriority))throw new TypeError("Bootstrap request priority must be an integer");if(t.bootstrapRequestPriority=o.bootstrapRequestPriority,t.dohEndpoints=[],o.dohEndpoints.forEach(e=>{if(!/^(https:\/\/)[a-z0-9]+([-.]{1}[a-z0-9]+)*\.[a-z]{2,}(:[0-9]{1,5})?(\/.*)?$/g.test(e))throw new TypeError("Invalid DNS over HTTPS (DoH) endpoint: "+e);t.dohEndpoints.push(e)}),t.dnsSeeds=[],o.dnsSeeds.forEach(e=>{if(!/^([a-z0-9]+[.-])+([a-z0-9]+)$/g.test(e))throw new TypeError("Invalid DNS seed: "+e);t.dnsSeeds.push(e)}),t.dnsServers=[],o.dnsServers.forEach(e=>{if(!/^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/g.test(e))throw new TypeError("Invalid DNS server: "+e);t.dnsServers.push(e)}),t.staticSeeds=[],o.staticSeeds.forEach(e=>{if(!/^https:\/\/([a-z0-9]+[.-])+([a-z0-9]+)$/g.test(e))throw new TypeError("Invalid static seed: "+e);t.staticSeeds.push(e)}),t.httpsSeeds=[],o.httpsSeeds.forEach(e=>{if(!/^(https:\/\/)[a-z0-9]+([-.]{1}[a-z0-9]+)*\.[a-z]{2,}(:[0-9]{1,5})?(\/.*)?$/g.test(e))throw new TypeError("Invalid HTTPS seed: "+e);t.httpsSeeds.push(e)}),!Number.isInteger(o.networkModulus))throw new TypeError("Network modulus must be an integer");if(o.networkModulus<=0)throw new RangeError("Network modulus must be positive");if(Math.log2(o.networkModulus)%1!=0)throw new TypeError("Network modulus must be a power of 2");if(t.networkModulus=o.networkModulus,!Number.isInteger(o.sectorMapSize))throw new TypeError("Sector map size must be an integer");if(o.sectorMapSize<=0)throw new RangeError("Sector map size must be positive");if(Math.log(o.sectorMapSize)/Math.log(4)%1!=0)throw new RangeError("Sector map size must be a power of 4");if(t.sectorMapSize=o.sectorMapSize,!Number.isInteger(o.logoSectorMapSize))throw new TypeError("Logo sector map size must be an integer");if(o.logoSectorMapSize<=0)throw new RangeError("Logo sector map size must be positive");if(Math.log(o.logoSectorMapSize)/Math.log(4)%1!=0)throw new RangeError("Logo sector map size must be a power of 4");if(t.logoSectorMapSize=o.logoSectorMapSize,!Number.isInteger(o.iconSectorMapSize))throw new TypeError("Icon sector map size must be an integer");if(o.iconSectorMapSize<=0)throw new RangeError("Icon sector map size must be positive");if(Math.log(o.iconSectorMapSize)/Math.log(4)%1!=0)throw new RangeError("Icon sector map size must be a power of 4");if(t.iconSectorMapSize=o.iconSectorMapSize,!Number.isInteger(o.version))throw new TypeError("Version must be an integer");if(o.version<=0)throw new RangeError("Version must be positive");if(t.version=o.version,"string"!=typeof o.networkIdentifier)throw new TypeError("Network identifier must be a string");if(0===o.networkIdentifier.length)throw new RangeError("Network identifier cannot be empty");if(t.networkIdentifier=o.networkIdentifier,!Number.isInteger(o.minSectorCoverage))throw new TypeError("Minimum sector coverage must be an integer");if(o.minSectorCoverage<0)throw new RangeError("Minimum sector coverage cannot be negative");if(t.minSectorCoverage=o.minSectorCoverage,!Number.isInteger(o.minHomeModCoverage))throw new TypeError("Minimum home mod coverage must be an integer");if(o.minHomeModCoverage<0)throw new RangeError("Minimum home mod coverage cannot be negative");if(t.minHomeModCoverage=o.minHomeModCoverage,!Number.isInteger(o.defaultIgnorePeriod))throw new TypeError("Default ignore period must be an integer");if(o.defaultIgnorePeriod<0)throw new RangeError("Default ignore period cannot be negative");if(t.defaultIgnorePeriod=o.defaultIgnorePeriod,!Number.isInteger(o.maxPeerShare))throw new TypeError("Maximum peer share must be an integer");if(o.maxPeerShare<=0)throw new RangeError("Maximum peer share must be positive");if(t.maxPeerShare=o.maxPeerShare,!Number.isInteger(o.queueTimeout))throw new TypeError("Queue timeout must be an integer");if(o.queueTimeout<=0)throw new RangeError("Queue timeout must be positive");if(t.queueTimeout=o.queueTimeout,o instanceof r){if(null===o.root)throw new TypeError("Options.root must be specified");return t.root=o.root,t}return new Promise((r,i)=>{e.new(o.root.fingerprint,o.root.publicKeyArmored).then(e=>{t.root=e,r(t)})})}}module.exports.ModularConfiguration=r;